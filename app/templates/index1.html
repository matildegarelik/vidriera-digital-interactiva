<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Fotos ‚Üí SVG (frente/lateral) ‚Üí 3D (GLB)</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body { margin:0; background:#0b0b0b; color:#eaeaea; font-family: system-ui, Arial, sans-serif; }
    .grid { display:grid; grid-template-columns: 420px 1fr; gap:16px; height:100vh; }
    aside { padding:14px; overflow:auto; border-right:1px solid #222; }
    main  { position:relative; }
    h3 { margin:10px 0 8px; font-size:16px; }
    h4 { margin:8px 0 6px; font-size:13px; opacity:.9 }
    label { display:block; margin:8px 0 4px; font-size:12px; opacity:.9; }
    input[type="range"], input[type="file"], input[type="color"], select { width:100%; }
    .row { display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; }
    .grp { margin:10px 0 16px; padding:10px; border:1px solid #222; border-radius:10px; background:#111; }
    button { margin-top:8px; padding:8px 10px; border:none; border-radius:8px; background:#1f6feb; color:#fff; cursor:pointer; }
    button.secondary { background:#444; }
    .pre { background:#111; border:1px solid #222; border-radius:10px; padding:8px; }
    .preview { background:#0f0f0f; border:1px solid #222; min-height:180px; max-height:280px; border-radius:8px; position: relative; overflow: hidden; }
    .preview svg { width: 100%; height: 100%; display: block; }
    #canvas3d { width:100%; height:100%; display:block; }
    #bar { position:absolute; top:10px; right:10px; z-index:10; background:rgba(0,0,0,.5); padding:8px 10px; border-radius:10px; }
    #loader {
    position: fixed; inset: 0; display: none;
    align-items: center; justify-content: center;
    background: rgba(0,0,0,.45); z-index: 9999;
    font: 14px/1 system-ui, Arial, sans-serif; color: #fff;
    }
    .loader {
    display: inline-flex; align-items: center; gap: 8px;
    background: rgba(0,0,0,.6); padding: 10px 14px; border-radius: 10px;
    }
    .loader-dot{ width:10px; height:10px; border-radius:50%; background:#1f6feb; animation:b .8s infinite alternate; opacity:.85 }
    .loader-dot:nth-child(2){ animation-delay:.1s }
    .loader-dot:nth-child(3){ animation-delay:.2s }
    @keyframes b{ from{ transform:scale(1); opacity:.6 } to{ transform:scale(1.6); opacity:1 } }

  </style>

  <!-- Import map para three y ejemplos -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <!-- ImageTracer para vectorizar en el navegador -->
  <script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.min.js"></script>
</head>
<body>
    <div id="loader">
    <div class="loader">
        <div class="loader-dot"></div>
        <div class="loader-dot"></div>
        <div class="loader-dot"></div>
        <span>Procesando‚Ä¶</span>
    </div>
    </div>

<div class="grid">
  <aside>
    <h3>1) Generar SVGs desde fotos</h3>

    <!-- FRENTE -->
    <div class="grp">
      <h4>Frente (aro/puente)</h4>
      <label>Foto frontal (fondo claro, luz pareja)</label>
      <input id="frontPhoto" type="file" accept="image/*" />
      <label>Modo vectorizado</label>
      <select id="frontMode">
        <option value="outline">Contorno (B&N)</option>
        <option value="fewcolors">Pocos colores</option>
      </select>
      <label>Umbral / detalle (ltres)</label>
      <input id="frontLtres" type="range" min="0.5" max="5" step="0.1" value="1.0" />
      <label>Suprimir paths chicos (pathomit)</label>
      <input id="frontPathomit" type="range" min="0" max="80" step="1" value="10" />
      <label>Colores (solo ‚ÄúPocos colores‚Äù)</label>
      <input id="frontNcolors" type="range" min="2" max="6" step="1" value="2" />
      <div class="row">
        <button id="frontToSVG">Generar SVG (frente)</button>
        <button id="frontDownload" class="secondary">Descargar SVG</button>
      </div>
      <div class="pre">
        <label>Estilo preview (aplica a la vista, no modifica la geometr√≠a)</label>
        <div class="row">
          <span>Stroke</span><input id="frontStroke" type="color" value="#ffffff" />
        </div>
        <div class="row">
          <span>Stroke width</span><input id="frontStrokeW" type="range" min="0" max="6" step="0.5" value="2" />
        </div>
        <div class="row">
          <span>Fill</span><input id="frontFill" type="color" value="#000000" />
        </div>
      </div>
      <div id="frontPreview" class="preview"></div>
    </div>

    <!-- LATERAL -->
    <div class="grp">
      <h4>Lateral (patilla)</h4>
      <label>Foto lateral (patilla con perfil claro)</label>
      <input id="sidePhoto" type="file" accept="image/*" />
      <label>Modo vectorizado</label>
      <select id="sideMode">
        <option value="outline">Contorno (B&N)</option>
        <option value="fewcolors">Pocos colores</option>
      </select>
      <label>Umbral / detalle (ltres)</label>
      <input id="sideLtres" type="range" min="0.5" max="5" step="0.1" value="1.0" />
      <label>Suprimir paths chicos (pathomit)</label>
      <input id="sidePathomit" type="range" min="0" max="80" step="1" value="8" />
      <label>Colores (solo ‚ÄúPocos colores‚Äù)</label>
      <input id="sideNcolors" type="range" min="2" max="6" step="1" value="2" />
      <div class="row">
        <button id="sideToSVG">Generar SVG (patilla)</button>
        <button id="sideDownload" class="secondary">Descargar SVG</button>
      </div>
      <div class="pre">
        <label>Estilo preview</label>
        <div class="row">
          <span>Stroke</span><input id="sideStroke" type="color" value="#ffffff" />
        </div>
        <div class="row">
          <span>Stroke width</span><input id="sideStrokeW" type="range" min="0" max="6" step="0.5" value="2" />
        </div>
        <div class="row">
          <span>Fill</span><input id="sideFill" type="color" value="#000000" />
        </div>
      </div>
      <div id="sidePreview" class="preview"></div>
    </div>

    <h3>2) Construir 3D</h3>
    <div class="grp">
      <label>Profundidad frente (mm ~ unidades)</label>
      <input id="depthFront" type="range" min="0.5" max="5" step="0.1" value="1.5">
      <label>Profundidad patilla (mm ~ unidades)</label>
      <input id="depthSide" type="range" min="0.5" max="5" step="0.1" value="1.2">
      <label>curveSegments (suavidad)</label>
      <input id="curveSeg" type="range" min="6" max="24" step="1" value="12">
      <label>Color frente</label>
      <input id="colFront" type="color" value="#dddddd">
      <label>Color patilla</label>
      <input id="colSide" type="color" value="#bbbbbb">
      <div class="row">
        <button id="build">Construir modelo</button>
        <button id="fit" class="secondary">Auto-encuadrar</button>
      </div>
    </div>

    <h3>3) Bisagras & Patillas</h3>
    <div class="grp">
      <div class="row"><label>Bisagra X (¬± sim√©tricas)</label><span id="hingeXv">0.060</span></div>
      <input id="hingeX" type="range" min="0.030" max="1.2" step="0.001" value="0.060">
      <div class="row"><label>Bisagra Y</label><span id="hingeYv">0.020</span></div>
      <input id="hingeY" type="range" min="-0.030" max="0.40" step="0.001" value="0.020">
      <div class="row"><label>Bisagra Z</label><span id="hingeZv">0.000</span></div>
      <input id="hingeZ" type="range" min="-0.030" max="0.030" step="0.001" value="0.000">

      <div class="row"><label>Rotaci√≥n patilla (grados)</label><span id="rotPatV">90</span></div>
      <input id="rotPat" type="range" min="0" max="180" step="1" value="90">

      <div class="row"><label>Escala patilla (largo)</label><span id="scalePatV">1.00</span></div>
      <input id="scalePat" type="range" min="0.6" max="1.6" step="0.01" value="1.00">
    </div>

    <h3>4) Exportar</h3>
    <div class="grp">
      <button id="exportGLB">Descargar GLB</button>
    </div>

    <p style="opacity:.8; font-size:12px;">
      Consejos: foto frontal para aro/puente; foto lateral para patilla.  
      El 3D es plano (extruido). Si la patilla tiene curva marcada, despu√©s podemos hacer TubeGeometry.
    </p>
  </aside>

  <main>
    <div id="bar">Arrastr√° con el mouse (OrbitControls)</div>
    <canvas id="canvas3d"></canvas>
  </main>
</div>

<script type="module">
import * as THREE from "three";
import { SVGLoader } from "three/examples/jsm/loaders/SVGLoader.js";
import { GLTFExporter } from "three/examples/jsm/exporters/GLTFExporter.js";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

// Polar: estado que llega de la API (alpha_glob, tint_hex, y_min, y_max, alpha_rows)
window.polarState = null;


const $loader = document.getElementById('loader');
function setLoading(on){ $loader.style.display = on ? 'flex' : 'none'; }

// Coloca el pivot de una patilla en la "bisagra": extremo frontal (minX o maxX)
// side queda solo informativo; hingeEnd define qu√© extremo usar en ambos
function makePivotAtHinge(group, side /* 'L' | 'R' */, hingeEnd = 'min') {
  const box = new THREE.Box3().setFromObject(group);
  const { min, max } = box;

  const xH = hingeEnd === 'max' ? max.x : min.x;   // üëà mismo extremo para ambos
  const hinge = new THREE.Vector3(
    xH,
    (min.y + max.y) * 0.5,
    (min.z + max.z) * 0.5
  );

  // mover geometr√≠a para que la bisagra quede en (0,0,0)
  group.position.sub(hinge);

  // pivot (para rotar/posicionar) + content (para espejar solo contenido)
  const pivot = new THREE.Group();
  const content = new THREE.Group();
  content.add(group);
  pivot.add(content);
  pivot.userData.content = content;
  return pivot;
}

// Duplica SIEMPRE una patilla base en izquierda y derecha.
// Si quer√©s que la derecha sea espejo real, pon√© mirrorRight:true.
function clonePatillasAlways(baseGroup, { mirrorRight = true } = {}) {
  // Clones crudos
  const Lraw = baseGroup.clone(true);
  const Rraw = baseGroup.clone(true);

  // Recentrar cada clon (para que el c√°lculo de bisagra sea limpio)
  [Lraw, Rraw].forEach(g => {
    const b = new THREE.Box3().setFromObject(g);
    const c = b.getCenter(new THREE.Vector3());
    g.position.sub(c);
  });

  // Crear pivots con bisagra en origen
  const L = makePivotAtHinge(Lraw, 'L');
  const R = makePivotAtHinge(Rraw, 'R');

  // üëà Espejo SOLO el contenido de la derecha (no el pivot)
  if (mirrorRight) {
    const content = R.userData.content;
    content.scale.x *= -1; // espejo en X
    // Con DoubleSide ya deber√≠a verse bien. Si hiciera falta:
    // content.traverse(o => { if (o.isMesh) o.material.side = THREE.DoubleSide; });
  }

  return { L, R };
}

function saveBufferAsFile(buffer, filename) {
  const blob = new Blob([buffer], { type: 'model/gltf-binary' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

// Devuelve un grupo NUEVO solo con Meshes ya horneados en coordenadas de mundo.
// No quedan pivots ni grupos con transform, as√≠ el GLB abre igual que en Three.
function bakeWorldTransforms(root) {
  const out = new THREE.Group();
  root.updateMatrixWorld(true);

  root.traverse(o => {
    if (o.isMesh && o.geometry) {
      const geom = o.geometry.clone();
      geom.applyMatrix4(o.matrixWorld);   // horne√° posici√≥n/rot/escala (incluye espejo)
      geom.computeVertexNormals();

      // material clon simple (evita referencias compartidas)
      const mat = o.material && o.material.clone ? o.material.clone() : o.material;
      if (mat) mat.side = THREE.DoubleSide;

      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.set(0,0,0);
      mesh.rotation.set(0,0,0);
      mesh.scale.set(1,1,1);
      out.add(mesh);
    }
  });

  // El 'out' no tiene transforms relevantes; queda todo tal cual se ve.
  out.position.set(0,0,0);
  out.rotation.set(0,0,0);
  out.scale.set(1,1,1);
  return out;
}

// ---------- FOTO ‚Üí SVG (ImageTracer) ----------
function vectorizeFromFile(file, { mode='outline', ltres=1.0, pathomit=8, ncolors=2 }) {
  return new Promise((resolve, reject) => {
    if (!file) return reject('No file');
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      // dibujar en canvas (¬°clave para evitar getContext undefined!)
      const canvas = document.createElement('canvas');
      canvas.width = img.width; canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);

      const optsOutline = { ltres: parseFloat(ltres), pathomit: parseInt(pathomit), numberofcolors: 2, scale:1 };
      const optsFew     = { ltres: parseFloat(ltres), pathomit: parseInt(pathomit), numberofcolors: parseInt(ncolors), scale:1 };
      const opts = (mode === 'fewcolors') ? optsFew : optsOutline;

      const imgData = ImageTracer.getImgdata(canvas);
      const svg = ImageTracer.imagedataToSVG(imgData, opts);
      URL.revokeObjectURL(url);
      resolve(svg);
    };
    img.onerror = reject;
    img.src = url;
  });
}

function applyPreviewStyle(svgText, { stroke = '#ffffff', strokeWidth = 2, fill = 'none' }) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(svgText, 'image/svg+xml');
  const svgEl = doc.documentElement;

  // Asegurar viewBox (si no viene)
  if (!svgEl.getAttribute('viewBox')) {
    let w = svgEl.getAttribute('width');
    let h = svgEl.getAttribute('height');
    if (w && h) {
      const wNum = parseFloat(w);
      const hNum = parseFloat(h);
      if (Number.isFinite(wNum) && Number.isFinite(hNum)) {
        svgEl.setAttribute('viewBox', `0 0 ${wNum} ${hNum}`);
      } else {
        svgEl.setAttribute('viewBox', '0 0 1000 1000'); // fallback
      }
    } else {
      svgEl.setAttribute('viewBox', '0 0 1000 1000');   // fallback
    }
  }

  // Hacer el SVG responsive a la ventanita
  svgEl.removeAttribute('width');
  svgEl.removeAttribute('height');
  svgEl.setAttribute('width', '100%');
  svgEl.setAttribute('height', '100%');
  svgEl.setAttribute('preserveAspectRatio', 'xMidYMid meet');

  // Aplicar estilo de preview a las figuras
  svgEl.querySelectorAll('path, polygon, polyline, rect, circle, ellipse').forEach(el => {
    el.removeAttribute('style'); // evita que estilos inline originales te pisen los cambios
    el.setAttribute('fill', fill);
    el.setAttribute('stroke', stroke);
    el.setAttribute('stroke-width', String(strokeWidth));
    el.setAttribute('stroke-linejoin', 'round');
    el.setAttribute('stroke-linecap', 'round');
  });

  return new XMLSerializer().serializeToString(svgEl);
}


function downloadTextAs(name, text, mime='image/svg+xml') {
  const blob = new Blob([text], { type: mime });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  URL.revokeObjectURL(a.href);
}

// ---------- UI FOTO‚ÜíSVG ----------
const front = {
  photo: document.getElementById('frontPhoto'),
  mode: document.getElementById('frontMode'),
  ltres: document.getElementById('frontLtres'),
  pathomit: document.getElementById('frontPathomit'),
  ncolors: document.getElementById('frontNcolors'),
  toSVG: document.getElementById('frontToSVG'),
  download: document.getElementById('frontDownload'),
  stroke: document.getElementById('frontStroke'),
  strokeW: document.getElementById('frontStrokeW'),
  fill: document.getElementById('frontFill'),
  preview: document.getElementById('frontPreview'),
  text: '' // SVG crudo
};

const side = {
  photo: document.getElementById('sidePhoto'),
  mode: document.getElementById('sideMode'),
  ltres: document.getElementById('sideLtres'),
  pathomit: document.getElementById('sidePathomit'),
  ncolors: document.getElementById('sideNcolors'),
  toSVG: document.getElementById('sideToSVG'),
  download: document.getElementById('sideDownload'),
  stroke: document.getElementById('sideStroke'),
  strokeW: document.getElementById('sideStrokeW'),
  fill: document.getElementById('sideFill'),
  preview: document.getElementById('sidePreview'),
  text: ''
};

function refreshPreview(which){
  if (!which.text) { which.preview.innerHTML=''; return; }
  const styled = applyPreviewStyle(which.text, {
    stroke: which.stroke.value,
    strokeWidth: parseFloat(which.strokeW.value),
    fill: which.fill.value
  });
  which.preview.innerHTML = styled;
}

front.toSVG.onclick = async ()=>{
  const f = front.photo.files?.[0];
  if(!f){ alert('Carg√° imagen o SVG frontal'); return; }
  setLoading(true);
  try{
    // Si sube un SVG directamente, lo usamos tal cual
    if (f.type.includes('svg') || /\.svg$/i.test(f.name)) {
      front.text = await f.text();
    } else {
      front.text = await vectorizeFromFile(f, {
        mode: front.mode.value,
        ltres: front.ltres.value,
        pathomit: front.pathomit.value,
        ncolors: front.ncolors.value
      });
    }
    refreshPreview(front);
  } catch(e){ alert('Error al procesar frente: ' + e); }
  finally { setLoading(false); }
};

side.toSVG.onclick = async ()=>{
  const f = side.photo.files?.[0];
  if(!f){ alert('Carg√° imagen o SVG de patilla'); return; }
  setLoading(true);
  try{
    if (f.type.includes('svg') || /\.svg$/i.test(f.name)) {
      side.text = await f.text();
    } else {
      side.text = await vectorizeFromFile(f, {
        mode: side.mode.value,
        ltres: side.ltres.value,
        pathomit: side.pathomit.value,
        ncolors: side.ncolors.value
      });
    }
    refreshPreview(side);
  } catch(e){ alert('Error al procesar patilla: ' + e); }
  finally { setLoading(false); }
};

[front.stroke, front.strokeW, front.fill].forEach(el=>el.addEventListener('input', ()=>refreshPreview(front)));
[side.stroke, side.strokeW, side.fill].forEach(el=>el.addEventListener('input', ()=>refreshPreview(side)));

front.download.onclick = ()=>{ if(front.text) downloadTextAs('frente.svg', front.text); };
side.download.onclick  = ()=>{ if(side.text)  downloadTextAs('patilla.svg', side.text);  };

// ---------- 3D (igual que antes, usando los SVG generados) ----------
const ui = {
  depthFront:document.getElementById('depthFront'),
  depthSide: document.getElementById('depthSide'),
  curveSeg:  document.getElementById('curveSeg'),
  colFront:  document.getElementById('colFront'),
  colSide:   document.getElementById('colSide'),

  hingeX: document.getElementById('hingeX'),
  hingeY: document.getElementById('hingeY'),
  hingeZ: document.getElementById('hingeZ'),
  hingeXv:document.getElementById('hingeXv'),
  hingeYv:document.getElementById('hingeYv'),
  hingeZv:document.getElementById('hingeZv'),

  rotPat:  document.getElementById('rotPat'),
  rotPatV: document.getElementById('rotPatV'),
  scalePat:document.getElementById('scalePat'),
  scalePatV:document.getElementById('scalePatV'),

  build: document.getElementById('build'),
  fit:   document.getElementById('fit'),
  exportGLB: document.getElementById('exportGLB'),
};

function upds(){
  ui.hingeXv.textContent = parseFloat(ui.hingeX.value).toFixed(3);
  ui.hingeYv.textContent = parseFloat(ui.hingeY.value).toFixed(3);
  ui.hingeZv.textContent = parseFloat(ui.hingeZ.value).toFixed(3);
  ui.rotPatV.textContent = parseInt(ui.rotPat.value);
  ui.scalePatV.textContent = parseFloat(ui.scalePat.value).toFixed(2);
}
['input','change'].forEach(ev=>{
  [ui.hingeX,ui.hingeY,ui.hingeZ,ui.rotPat,ui.scalePat].forEach(el=>el.addEventListener(ev, ()=>{ upds(); positionPatillas(); }));
  [ui.depthFront,ui.depthSide,ui.curveSeg,ui.colFront,ui.colSide].forEach(el=>el.addEventListener(ev, ()=> rebuildIfPossible()));
});
upds();

// 3D setup
const canvas = document.getElementById('canvas3d');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x141414);

const camera = new THREE.PerspectiveCamera(45, 1, 0.001, 100);
camera.position.set(0, 0, 0.35);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(1,1,1);
scene.add(dir);

function resize(){
  const w = canvas.clientWidth, h = canvas.clientHeight || 300;
  renderer.setSize(w, h, false);
  camera.aspect = w/h; camera.updateProjectionMatrix();
}
new ResizeObserver(resize).observe(canvas);

function fitCameraToObject(cam, obj, offset = 1.25) {
  const box = new THREE.Box3().setFromObject(obj);
  const size = new THREE.Vector3(); box.getSize(size);
  const center = new THREE.Vector3(); box.getCenter(center);
  const maxSize = Math.max(size.x, size.y, size.z);
  const fov = cam.fov * (Math.PI / 180);
  const dist = (maxSize / (2 * Math.tan(fov / 2))) * offset;
  cam.position.set(center.x, center.y, dist);
  cam.near = dist / 100; cam.far = dist * 100; cam.updateProjectionMatrix();
  cam.lookAt(center);
  controls.target.copy(center);
}

function colorToInt(hex){ return parseInt(hex.replace('#','0x')); }

function extrudeFromSVGText(
  svgText,
  { depth = 0.015, curveSegments = 12, color = 0xdddddd, role = 'generic' }
) {
  const loader = new SVGLoader();
  const data = loader.parse(svgText);

  const mat = new THREE.MeshStandardMaterial({
    color, metalness: 0.1, roughness: 0.7, side: THREE.DoubleSide
  });

  const group = new THREE.Group();
  const opts = { depth, bevelEnabled: false, curveSegments };

  // √Årea de referencia robusta
  let refBox = null;
  for (const path of data.paths) {
    const subs = path.subPaths || [];
    for (const sp of subs) {
      const pts = sp.getPoints(8);
      if (pts.length) {
        const b = new THREE.Box2().setFromPoints(pts);
        refBox = refBox ? refBox.union(b) : b.clone();
      }
    }
  }
  if (!refBox) refBox = new THREE.Box2(new THREE.Vector2(0,0), new THREE.Vector2(1000,1000));
  const refArea = Math.max(1, (refBox.max.x - refBox.min.x) * (refBox.max.y - refBox.min.y));

  const MAX_AREA_RATIO = role === 'front' ? 0.50 : 0.60;
  const MIN_AREA       = role === 'front' ? 400  : 150;

  let kept = 0;
  for (const path of data.paths) {
    let shapes = [];
    try {
      shapes = path.toShapes(true);
      if (!shapes || !shapes.length) shapes = SVGLoader.createShapes(path);
    } catch { shapes = SVGLoader.createShapes(path); }

    for (const shape of shapes) {
      // filtrar fondo/ruido por √°rea AABB
      const pts = shape.getPoints(12);
      const box2 = new THREE.Box2().setFromPoints(pts);
      const area  = Math.max(0, (box2.max.x - box2.min.x) * (box2.max.y - box2.min.y));
      const ratio = area / refArea;
      if (ratio > MAX_AREA_RATIO) continue;
      if (area < MIN_AREA) continue;

      const geom = new THREE.ExtrudeGeometry(shape, opts);
      geom.scale(0.002, -0.002, 0.002); // px‚Üím aprox y flip Y
      group.add(new THREE.Mesh(geom, mat));
      kept++;
    }
  }

  // fallback si todo fue filtrado
  if (kept === 0) {
    let best = null, bestA = 0;
    for (const p of data.paths) {
      const S = SVGLoader.createShapes(p);
      for (const s of S) {
        const a = Math.abs(typeof s.getArea === 'function' ? s.getArea() : 0);
        if (a > bestA) { bestA = a; best = s; }
      }
    }
    if (best) {
      const g = new THREE.ExtrudeGeometry(best, opts);
      g.scale(0.002, -0.002, 0.002);
      group.add(new THREE.Mesh(g, mat));
    }
  }

  // centrar y dejar en plano XY
  const b = new THREE.Box3().setFromObject(group);
  if (!b.isEmpty()) {
    const c = b.getCenter(new THREE.Vector3());
    group.position.sub(c);
  }
  //group.rotation.x = -Math.PI/2;
  return group;
}

// Estado del modelo
let marco = null, patillaBase = null, patillaL = null, patillaR = null;
const assembled = new THREE.Group(); scene.add(assembled);

async function rebuildIfPossible(){
  if (!front.text || !side.text) return;
  buildModel();
}

ui.build.onclick = async ()=>{
  if(!front.text){ alert('Gener√° o carg√° el SVG frontal primero.'); return; }
  if(!side.text){  alert('Gener√° o carg√° el SVG de patilla primero.'); return; }
  setLoading(true);
  try{
    buildModel();
    fitCameraToObject(camera, assembled);
  } finally {
    setLoading(false);
  }
};

ui.fit.onclick = ()=> { if(assembled.children.length) fitCameraToObject(camera, assembled); };

function buildModel(){
  assembled.clear(); marco = patillaBase = patillaL = patillaR = null;

  // Frente
  marco = extrudeFromSVGText(front.text, {
    depth: parseFloat(ui.depthFront.value)/100.0,
    curveSegments: parseInt(ui.curveSeg.value),
    color: colorToInt(ui.colFront.value),
    role: 'front'
  });
  assembled.add(marco);

  // Patillas base
  const base = extrudeFromSVGText(side.text, {
    depth: parseFloat(ui.depthSide.value)/100.0,
    curveSegments: parseInt(ui.curveSeg.value),
    color: colorToInt(ui.colSide.value),
    role: 'side'
  });

  // Separar (o clonar) y poner pivot en bisagra
  const { L, R } = clonePatillasAlways(base, { mirrorRight: true });
  patillaL = L;
  patillaR = R;
  assembled.add(patillaL, patillaR);

  // Colocar
  positionPatillas();
  fitCameraToObject(camera, assembled);
}

function positionPatillas(){
  if(!patillaL || !patillaR || !marco) return;

  const hx = parseFloat(ui.hingeX.value);  // desplazamiento lateral desde el centro
  const hy = parseFloat(ui.hingeY.value);  // altura
  const hz = parseFloat(ui.hingeZ.value);  // profundidad
  const openRad = THREE.MathUtils.degToRad(parseInt(ui.rotPat.value)); // 0..180
  const scaleP = parseFloat(ui.scalePat.value);

  // Reset
  [patillaL, patillaR].forEach(p=>{
    p.position.set(0,0,0);
    p.rotation.set(0,0,0);  // üëà sin -PI/2 aqu√≠
    p.scale.set(1,1,1);
  });

  // Largo de patilla
  patillaL.scale.multiplyScalar(scaleP);
  patillaR.scale.multiplyScalar(scaleP);

  // Apertura transversal al marco: girar en Y ¬±Œ∏ para que salgan hacia ¬±Z
  patillaL.rotation.y = +openRad;  // izquierda
  patillaR.rotation.y = -openRad;  // derecha

  // Colocar en bisagras (sim√©trico en X)
  patillaL.position.set(-hx, hy, hz);
  patillaR.position.set( hx, hy, hz);
}

// Export GLB
document.getElementById('exportGLB').onclick = async () => {
  if (!assembled.children.length) {
    alert('Constru√≠ el modelo primero.');
    return;
  }

  try {
    // 1) Clonamos y ‚Äúhorneamos‚Äù transforms para evitar escalas negativas
    const exportRoot = bakeWorldTransforms(assembled);

    // 2) Exportamos en binario s√≠ o s√≠
    const exporter = new GLTFExporter();
    const result = await exporter.parseAsync(exportRoot, {
      binary: true,               // üëà fuerza GLB (ArrayBuffer)
      onlyVisible: true,
      includeCustomExtensions: true,
      forcePowerOfTwoTextures: false
    });

    // 3) Aseguramos que sea ArrayBuffer (si no, hacemos fallback a .gltf)
    if (result instanceof ArrayBuffer) {
      saveBufferAsFile(result, 'marco_completo.glb');
    } else {
      // Fallback por si tu three.js no devuelve ArrayBuffer
      const json = JSON.stringify(result);
      const blob = new Blob([json], { type: 'model/gltf+json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'marco_completo.gltf';
      a.click();
      URL.revokeObjectURL(a.href);
      alert('Se export√≥ como .gltf (no .glb) porque el exportador devolvi√≥ JSON.\nEl .glb deber√≠a generarse con binary:true (revis√° la versi√≥n de three).');
    }
  } catch (err) {
    console.error('Export error:', err);
    alert('Error exportando GLB: ' + err);
  }
};


// render
function tick(){
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
tick();
</script>
</body>
</html>
