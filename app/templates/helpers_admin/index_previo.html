<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Index Previo – Aplanado y Pintura</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/panel_admin.css') }}">
  <style>
    /* Ajustes mínimos de layout específico de este index */
    .steps { display: grid; gap: 12px; }
    .step { border:1px solid #222; border-radius: 10px; padding: 12px; background:#111; display:none; opacity:0; transform: translateY(8px); transition: opacity .25s, transform .25s; }
    .step.active { display:block; opacity:1; transform: translateY(0); }
    .step h3 { margin:0 0 6px; font-size:15px; }
    .cols { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .previewBox { background:#0f0f0f; border:1px solid #222; border-radius:8px; min-height:240px; display:grid; place-items:center; overflow:hidden; }
    .previewBox canvas, .previewBox img { max-width:100%; max-height:440px; display:block; }
    .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .mini { font-size:12px; opacity:.85; }
    .chip { padding:4px 8px; border:1px solid #333; border-radius:8px; }
    .row2 { display:flex; gap:8px; align-items:center; }
    .spacer { flex:1 }
    .hint { font-size:12px; opacity:.8 }
  </style>
</head>
<body>

<!-- Loader -->
<div id="loader"><div class="loader">
  <div class="loader-dot"></div><div class="loader-dot"></div><div class="loader-dot"></div>
  <span style="color:#fff">Procesando…</span>
</div></div>

<div class="prev-grid">
  <main class="prev">
    <div class="steps">

      <!-- Paso 1: entradas -->
      <div class="step" data-step="1">
        <h3>1) Cargar 3 fotos</h3>
        <div class="grp">
          <label>Frente (lentes de frente)</label>
          <input id="inFront" type="file" accept="image/*" />
          <label>Costado (lentes de costado)</label>
          <input id="inSide" type="file" accept="image/*" />
          <label>Fondo solo (mismo setup de iluminación)</label>
          <input id="inBg" type="file" accept="image/*" />
          <div class="row">
            <button id="btnFlatten">Aplanar</button><br/>
            <span class="hint">Conviene que las 3 fotos tengan el **mismo encuadre**.</span>
          </div>
        </div>
        <div class="wizard-nav">
            <button class="js-next" data-goto="2" id="goStep2" disabled>Siguiente</button>
        </div>
      </div>

      <!-- Paso 2: resultado aplanado -->
      <div class="step" data-step="2">
        <h3>2) Resultados aplanados</h3>
        <div class="cols">
          <div>
            <h4>Frente (aplanada)</h4>
            <div class="previewBox"><canvas id="cvFrontFlat"></canvas></div>
          </div>
          <div>
            <h4>Costado (aplanada)</h4>
            <div class="previewBox"><canvas id="cvSideFlat"></canvas></div>
          </div>
        </div>
        <div class="wizard-nav">
            <button class="secondary js-prev" data-goto="1">Volver</button>
            <button class="js-next" data-goto="3">Siguiente</button>
        </div>
      </div>

      <!-- Paso 3: pintar sobre costado aplanado -->
      <div class="step" data-step="3">
        <h3>3) Pintar sobre la patilla aplanada</h3>
        <div class="grp toolbar">
          <div class="row2">
            <label class="mini">Grosor</label>
            <input id="brushSize" type="range" min="1" max="80" step="1" value="25">
          </div>
          <div class="row2">
            <label class="mini">Color</label>
            <input id="brushColor" type="color" value="#ffffff">
          </div>
          <button id="pickColor" class="secondary">Cuentagotas</button>
          <button id="useBgColor" class="secondary">Usar color de fondo</button>
          <span class="chip mini">Pintá para “limpiar” lo innecesario</span>
          <span class="spacer"></span>
          <button id="clearPaint" class="secondary">Limpiar pintura</button>
          <button id="undoPaint" class="secondary">Deshacer</button>
        </div>
        <div class="previewBox">
          <!-- Lienzo de pintura: imagen aplanada + overlay -->
          <canvas id="cvPaint"></canvas>
        </div>
        <div class="wizard-nav">
            <button class="secondary js-prev" data-goto="2">Volver</button>
            <button class="js-next" data-goto="4">Siguiente</button>
        </div>
      </div>

      <!-- Paso 4: descarga -->
      <div class="step" data-step="4">
        <h3>4) Descargar</h3>
        <div class="row">
          <button id="dlFront">Descargar Frente (aplanada)</button>
          <button id="dlSide">Descargar Costado (aplanada + pintura)</button>
          <button id="dlBg">Descargar Fondo</button>
          <button id="btnSaveModel" class="primary">Guardar en modelo</button>
          <span id="saveStatus" class="hint"></span>
        </div>
      </div>
    </div>
</main>

  
</div>

<script type="module">
  const MODEL_ID = {{ model_id|default(None)|tojson }};
  const PRELOADED = {
    front: {{ front_img_url|default(None)|tojson }},
    side : {{ side_img_url|default(None)|tojson }},
    bg   : {{ bg_img_url|default(None)|tojson }},
  };


/* ======================
   Utilidades generales
   ====================== */
function setLoading(on){
  const el = document.getElementById('loader');
  el.style.display = on ? 'flex' : 'none';
}

function urlToImage(src){
  return new Promise((res, rej)=>{
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = ()=> res(img);
    img.onerror = rej;
    img.src = src;
  });
}


function fileToImage(file){
  return new Promise((res, rej)=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{ URL.revokeObjectURL(url); res(img); };
    img.onerror= rej;
    img.src = url;
  });
}

function createCanvasLike(w,h){
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  return c;
}

/* ======================
   sRGB <-> lineal
   ====================== */
function srgbToLinear(v){
  // v en [0,1]
  return (v <= 0.04045) ? (v/12.92) : Math.pow((v+0.055)/1.055, 2.4);
}
function linearToSrgb(v){
  return (v <= 0.0031308) ? (12.92*v) : (1.055*Math.pow(v,1/2.4)-0.055);
}
function srgbArrToLinear(src, dst){
  // src Uint8ClampedArray RGBA; dst Float32Array RGB (opcional) o in-place float
  const N = src.length/4;
  const out = dst || new Float32Array(N*3);
  for(let i=0;i<N;i++){
    const r = src[4*i]/255, g = src[4*i+1]/255, b = src[4*i+2]/255;
    out[3*i]   = srgbToLinear(r);
    out[3*i+1] = srgbToLinear(g);
    out[3*i+2] = srgbToLinear(b);
  }
  return out;
}
function linearToSrgbImageData(srcLin, w, h){
  const out = new ImageData(w, h);
  const N = w*h;
  for(let i=0;i<N;i++){
    out.data[4*i  ] = Math.round(255 * Math.min(1, Math.max(0, linearToSrgb(srcLin[3*i]))));
    out.data[4*i+1] = Math.round(255 * Math.min(1, Math.max(0, linearToSrgb(srcLin[3*i+1]))));
    out.data[4*i+2] = Math.round(255 * Math.min(1, Math.max(0, linearToSrgb(srcLin[3*i+2]))));
    out.data[4*i+3] = 255;
  }
  return out;
}

/* ======================
   Aplanado por división
   ====================== */
async function flattenWithBackground({imgFront, imgSide, imgBg}){
  // 1) Normalizamos tamaños a la del fondo (asumimos mismo encuadre)
  const W = imgBg.naturalWidth, H = imgBg.naturalHeight;

  // Canvases base
  const cFront = createCanvasLike(W,H),  xF = cFront.getContext('2d');
  const cSide  = createCanvasLike(W,H),  xS = cSide.getContext('2d');
  const cBg    = createCanvasLike(W,H),  xB = cBg.getContext('2d');

  xF.drawImage(imgFront, 0,0, W,H);
  xS.drawImage(imgSide , 0,0, W,H);
  xB.drawImage(imgBg   , 0,0, W,H);

  // 2) sRGB -> lineal
  const idF = xF.getImageData(0,0,W,H);
  const idS = xS.getImageData(0,0,W,H);
  const idB = xB.getImageData(0,0,W,H);

  const F_lin = srgbArrToLinear(idF.data); // Float32 RGB
  const S_lin = srgbArrToLinear(idS.data);
  const B_lin = srgbArrToLinear(idB.data);

  // 3) Campo de iluminación lenta v_lin ≈ blur grande del fondo
  //    (blur por navegador, equivalente conceptual a Gauss sigma~45px)
  const cBlur = createCanvasLike(W,H), xBLUR = cBlur.getContext('2d');
  xBLUR.filter = 'blur(45px)';
  xBLUR.drawImage(imgBg, 0,0, W,H);
  const idV = xBLUR.getImageData(0,0,W,H);
  const V_srgb = idV.data;
  const V_lin = srgbArrToLinear(V_srgb);

  // 4) División por canal + clip (evita divisiones por ~0)
  const eps = 1e-4, N = W*H;
  const F_flat = new Float32Array(N*3);
  const S_flat = new Float32Array(N*3);
  for(let i=0;i<N;i++){
    const rI=3*i, rV=3*i;
    F_flat[rI  ] = Math.min(1, Math.max(0, F_lin[rI  ] / Math.max(eps, V_lin[rV  ])));
    F_flat[rI+1] = Math.min(1, Math.max(0, F_lin[rI+1] / Math.max(eps, V_lin[rV+1])));
    F_flat[rI+2] = Math.min(1, Math.max(0, F_lin[rI+2] / Math.max(eps, V_lin[rV+2])));
    S_flat[rI  ] = Math.min(1, Math.max(0, S_lin[rI  ] / Math.max(eps, V_lin[rV  ])));
    S_flat[rI+1] = Math.min(1, Math.max(0, S_lin[rI+1] / Math.max(eps, V_lin[rV+1])));
    S_flat[rI+2] = Math.min(1, Math.max(0, S_lin[rI+2] / Math.max(eps, V_lin[rV+2])));
  }

  // 5) Volver a sRGB
  const outFront = linearToSrgbImageData(F_flat, W, H);
  const outSide  = linearToSrgbImageData(S_flat, W, H);
  const B_flat = new Float32Array(N*3);
  for (let i=0;i<N;i++){
    const j=3*i;
    B_flat[j  ] = Math.min(1, Math.max(0, B_lin[j  ] / Math.max(eps, V_lin[j  ])));
    B_flat[j+1] = Math.min(1, Math.max(0, B_lin[j+1] / Math.max(eps, V_lin[j+1])));
    B_flat[j+2] = Math.min(1, Math.max(0, B_lin[j+2] / Math.max(eps, V_lin[j+2])));
  }
  const outBg = linearToSrgbImageData(B_flat, W, H);

  return { outFront, outSide, outBg, size:{W,H} };
  }

/* ======================
   Pintura sobre costado
   ====================== */
function makePainter(canvas, baseImageData){
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const W = baseImageData.width, H = baseImageData.height;

  canvas.width  = W;
  canvas.height = H;
  canvas.style.maxWidth  = '100%';
  canvas.style.height    = 'auto';


  // Capa de pintura separada (solo strokes)
  const paint = createCanvasLike(W, H);
  const xp = paint.getContext('2d', { willReadFrequently: true });
  xp.lineCap = 'round';
  xp.lineJoin = 'round';
  xp.globalCompositeOperation = 'source-over';

  // ========== Historial para Deshacer ==========
  const MAX_HISTORY = 50;
  const history = [];
  function snapshot(){              // guarda SOLO la capa de pintura
    try {
      history.push(xp.getImageData(0,0,W,H));
      if (history.length > MAX_HISTORY) history.shift();
    } catch {}
  }
  function undo(){
    if (!history.length) return;
    const last = history.pop();
    xp.clearRect(0,0,W,H);
    if (last) xp.putImageData(last, 0,0);
    render();
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    ctx.putImageData(baseImageData, 0,0);
    ctx.drawImage(paint, 0,0);
  }

  // Estado del pincel
  let brushColor = '#ffffff';
  let brushSize  = 25;

  // grosor en PX DE PANTALLA: compensar por escala visual
  function setBrush(col, size){
    if (col)  brushColor = col;
    if (size) brushSize  = size;

    const rect = canvas.getBoundingClientRect();
    const screenToImage = W / rect.width;  // px pantalla -> px imagen
    xp.strokeStyle = brushColor;
    xp.lineWidth   = Math.max(1, (size ?? brushSize) * screenToImage);
  }

  // Interacción
  let drawing = false;
  function toXY(e){
    const r = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - r.left) * (W / r.width),
      y: (e.clientY - r.top ) * (H / r.height)
    };
  }
  function onDown(e){
    e.preventDefault();
    snapshot();               // <- para deshacer este trazo
    const {x,y} = toXY(e);
    xp.beginPath();
    xp.moveTo(x,y);
    drawing = true;
  }
  function onMove(e){
    if(!drawing) return;
    const {x,y} = toXY(e);
    xp.lineTo(x,y);
    xp.stroke();
    render();
  }
  function endStroke(){
    if(!drawing) return;
    drawing = false;
    xp.closePath();
    render();
  }

  canvas.addEventListener('pointerdown', onDown);
  canvas.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', endStroke);
  canvas.addEventListener('pointerleave', endStroke);
  canvas.addEventListener('pointercancel', endStroke);

  function clearPaint(){
    snapshot();               // <- deshacer también este “clear”
    xp.clearRect(0,0,W,H);
    render();
  }

  function pickAt(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    const x = Math.floor((clientX-r.left) * (W/r.width));
    const y = Math.floor((clientY-r.top ) * (H/r.height));
    const d = ctx.getImageData(x,y,1,1).data;   // base + pintura
    return '#'+[d[0],d[1],d[2]].map(v=>v.toString(16).padStart(2,'0')).join('');
  }

  // IMPORTANTÍSIMO: inicializar el pincel una vez
  setBrush(brushColor, brushSize);
  render();

  return {
    render,
    setBrush,
    clearPaint,
    undo,
    pickAt,
    getPNG: ()=> canvas.toDataURL('image/png')
  };
}



/* ======================
   Wiring UI
   ====================== */
const ui = {
  inFront: document.getElementById('inFront'),
  inSide:  document.getElementById('inSide'),
  inBg:    document.getElementById('inBg'),
  btnFlatten: document.getElementById('btnFlatten'),

  cvFrontFlat: document.getElementById('cvFrontFlat'),
  cvSideFlat:  document.getElementById('cvSideFlat'),
  cvPaint:     document.getElementById('cvPaint'),

  brushSize:  document.getElementById('brushSize'),
  brushColor: document.getElementById('brushColor'),
  pickColor:  document.getElementById('pickColor'),
  useBgColor: document.getElementById('useBgColor'),
  clearPaint: document.getElementById('clearPaint'),
  undoPaint: document.getElementById('undoPaint'),

  dlFront: document.getElementById('dlFront'),
  dlSide:  document.getElementById('dlSide'),
  dlBg:  document.getElementById('dlBg')
};

// Estado
let imgFront=null, imgSide=null, imgBg=null;
let painter=null; // controlador de pintura
let outFrontPNG=null; // dataURL para descarga
let outTemplePaintedPNG=null;
let outSidePNG=null;
let outBgPNG=null;

async function maybeAutoloadFromServer(){
  // si vienen las 3
  if (PRELOADED.front && PRELOADED.side && PRELOADED.bg){
    setLoading(true);
    try{
      [imgFront, imgSide, imgBg] = await Promise.all([
        urlToImage(PRELOADED.front),
        urlToImage(PRELOADED.side),
        urlToImage(PRELOADED.bg),
      ]);
      // Aplanar directamente
      const { outFront, outSide, outBg, size:{W,H} } =
        await flattenWithBackground({imgFront,imgSide,imgBg});

      // mostrar
      const xF = ui.cvFrontFlat.getContext('2d'); ui.cvFrontFlat.width=W; ui.cvFrontFlat.height=H;
      const xS = ui.cvSideFlat .getContext('2d'); ui.cvSideFlat .width=W; ui.cvSideFlat .height=H;
      xF.putImageData(outFront, 0,0);
      xS.putImageData(outSide , 0,0);

      // painter + PNGs
      painter = makePainter(ui.cvPaint, outSide);
      ui.undoPaint.onclick  = ()=> painter.undo(); 
      ui.clearPaint.onclick = ()=> painter.clearPaint();
      ui.brushSize.oninput  = ()=> painter.setBrush(ui.brushColor.value, parseInt(ui.brushSize.value,10));
      ui.brushColor.oninput = ()=> painter.setBrush(ui.brushColor.value, parseInt(ui.brushSize.value,10));

      painter.setBrush(ui.brushColor.value, parseInt(ui.brushSize.value,10));
      painter.render();
      outFrontPNG = ui.cvFrontFlat.toDataURL('image/png');
      outSidePNG  = ui.cvSideFlat .toDataURL('image/png');
      const cBg = createCanvasLike(W,H); cBg.getContext('2d').putImageData(outBg,0,0);
      outBgPNG = cBg.toDataURL('image/png');

      // saltar a paso 2
      document.getElementById('goStep2').disabled = false;
      showStep(2);
    } finally {
      setLoading(false);
    }
  }
}
maybeAutoloadFromServer();


// Carga de imágenes
ui.inFront.addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; imgFront=await fileToImage(f); });
ui.inSide .addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; imgSide =await fileToImage(f); });
ui.inBg   .addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; imgBg   =await fileToImage(f); });

ui.btnFlatten.addEventListener('click', async ()=>{
  if(!imgFront || !imgSide || !imgBg){ alert('Cargá las 3 fotos primero.'); return; }
  setLoading(true);
  try{
    const { outFront, outSide, outBg, size:{W,H} } = await flattenWithBackground({imgFront,imgSide,imgBg});

    // Mostrar en canvases
    const xF = ui.cvFrontFlat.getContext('2d'); ui.cvFrontFlat.width=W; ui.cvFrontFlat.height=H;
    const xS = ui.cvSideFlat .getContext('2d'); ui.cvSideFlat .width=W; ui.cvSideFlat .height=H;
    xF.putImageData(outFront, 0,0);
    xS.putImageData(outSide , 0,0);

    // Preparar lienzo de pintura con la patilla aplanada
    painter = makePainter(ui.cvPaint, outSide);
    painter.render();

    // Guardar PNG del frente aplanado (para descarga directa)
    outFrontPNG = ui.cvFrontFlat.toDataURL('image/png');
    outSidePNG  = ui.cvSideFlat.toDataURL('image/png');
    const cBg = createCanvasLike(W,H);
    cBg.getContext('2d').putImageData(outBg,0,0);
    outBgPNG = cBg.toDataURL('image/png');

    // Config inicial pincel
    painter.setBrush(ui.brushColor.value, parseInt(ui.brushSize.value,10));

    // Cuentagotas (click único)
    ui.pickColor.onclick = ()=>{
      const once = (e)=>{
        const col = painter.pickAt(e.clientX, e.clientY);
        ui.brushColor.value = col;
        painter.setBrush(col, parseInt(ui.brushSize.value,10));
        ui.cvPaint.removeEventListener('click', once);
      };
      ui.cvPaint.addEventListener('click', once);

    };

    // Usar color promedio del fondo aplanado (tomado de la propia costado aplanada)
    ui.useBgColor.onclick = ()=>{
      const ctx = ui.cvSideFlat.getContext('2d');
      const id  = ctx.getImageData(0,0,W,H).data;
      let r=0,g=0,b=0, n=W*H;
      for(let i=0;i<n;i++){ r+=id[4*i]; g+=id[4*i+1]; b+=id[4*i+2]; }
      r=Math.round(r/n); g=Math.round(g/n); b=Math.round(b/n);
      const hex = '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
      ui.brushColor.value = hex;
      painter.setBrush(hex, parseInt(ui.brushSize.value,10));
    };

    // Grosor / color inputs
    ui.brushSize.oninput = ()=> painter.setBrush(ui.brushColor.value, parseInt(ui.brushSize.value,10));
    ui.brushColor.oninput= ()=> painter.setBrush(ui.brushColor.value, parseInt(ui.brushSize.value,10));

    // Limpiar pintura
    ui.clearPaint.onclick = ()=> painter.clearPaint();
    ui.undoPaint.onclick = ()=> painter.undo();

    
    document.getElementById('goStep2').disabled = false;

  } finally {
    setLoading(false);
  }
});

// Descargas
ui.dlFront.onclick = ()=>{
  if(!outFrontPNG){ alert('Generá primero la imagen aplanada.'); return; }
  const a = document.createElement('a'); a.href = outFrontPNG; a.download = 'frente_aplanada.png'; a.click();
};
ui.dlSide.onclick = ()=>{
  if(!painter){ alert('Generá primero la imagen aplanada.'); return; }
  const png = painter.getPNG();
  outTemplePaintedPNG = png;               // <-- GUARDAR para el POST
  const a = document.createElement('a'); a.href = png; a.download = 'costado_aplanada_pintada.png'; a.click();
};

ui.dlBg.onclick = ()=>{
  if(!outBgPNG){ alert('Generá primero la imagen aplanada.'); return; }
  const a = document.createElement('a'); a.href = outBgPNG; a.download = 'fondo_aplanado.png'; a.click();
};

document.getElementById('btnSaveModel').addEventListener('click', async ()=>{
  const el = document.getElementById('saveStatus');
  try{
    if (!MODEL_ID){ alert('Falta model_id'); return; }

    if (!outTemplePaintedPNG && painter){
      outTemplePaintedPNG = painter.getPNG();
    }

    const payload = {
      front_flattened:  outFrontPNG || null,
      side_flattened:   outSidePNG  || null,
      temple_flattened: outTemplePaintedPNG || null,
      bg_flattened:     outBgPNG    || null,
    };

    el.textContent = 'Guardando…';
    const r = await fetch(`/_admin_helpers/aplanar_imagenes/${MODEL_ID}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const j = await r.json();

    if (j.ok && j.redirect) {
        window.location = j.redirect;   // volvemos al detalle del lente
    } else {
      console.error(j);
      alert('No se pudo guardar el modelo');
    }

    if (!j.ok) throw new Error('Error en guardado');

    el.textContent = '¡Guardado!';
    setTimeout(()=> el.textContent='', 2000);
  }catch(err){
    console.error(err);
    el.textContent = 'Error al guardar';
  }
});



/* ========== Wizard controller ========== */
let currentStep = 1;
const steps = [...document.querySelectorAll('.step')];

function showStep(n){
  currentStep = n;
  steps.forEach(s => s.classList.toggle('active', parseInt(s.dataset.step,10) === n));
  const active = steps.find(s => s.classList.contains('active'));
  if (active) active.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

document.addEventListener('click', (e)=>{
  const nextBtn = e.target.closest('.js-next');
  const prevBtn = e.target.closest('.js-prev');
  if (nextBtn){
    const to = parseInt(nextBtn.dataset.goto, 10);
    if (!isNaN(to)) showStep(to);
  }
  if (prevBtn){
    const to = parseInt(prevBtn.dataset.goto, 10);
    if (!isNaN(to)) showStep(to);
  }
});
showStep(1);

</script>
</body>
</html>
