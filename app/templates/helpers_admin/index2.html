<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="{{ url_for('static', filename='css/panel_admin.css') }}">
  <title>GLB sobre la cara (FaceMesh + Three.js)</title>

  <!-- Import Map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="wrap">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="three"></canvas>

    <div id="ui">
      <h3>GLB sobre la cara</h3>

      <!-- Carga/estado del GLB -->
      {% if ar_model and ar_model.path_to_glb %}
        <div class="alert alert-success mb-2">
          GLB cargado:
          <code class="d-inline-block text-truncate" style="max-width: 420px;">
            {{ ar_model.path_to_glb }}
          </code>
        </div>
        <input type="hidden" id="glbSrc"
              value="{{ url_for('main.uploads',
                        filename=(ar_model.path_to_glb or '')
                                |replace('\\','/')
                                |replace('uploads/','')
                                |trim('/') ) }}">
      {% else %}
        <div class="mb-2">
          <label class="form-label">Subí el modelo (.glb)</label>
          <input type="file" id="glbFile" class="form-control" accept=".glb,model/gltf-binary">
        </div>
        <input type="hidden" id="glbSrc" value="">
      {% endif %}

      <div class="row">
        <label><input id="trackFace" type="checkbox"> Seguir cara</label><span></span>
      </div>
      <div class="row">
        <label><input id="use3D" type="checkbox"> Yaw/Pitch (3D)</label><span></span>
      </div>

      <h4 style="margin:6px 0 0; font-size:13px;">Rotación inicial del GLB</h4>
      <div class="row">
            <label>Rot X <small id="rx0v">0°</small></label>
            <input id="rotX0" type="range" min="-180" max="180" step="1" value="-180">
        </div>
        <div class="row">
            <label>Rot Y <small id="ry0v">0°</small></label>
            <input id="rotY0" type="range" min="-180" max="180" step="1" value="0">
            </div>
            <div class="row">
            <label>Rot Z <small id="rz0v">0°</small></label>
            <input id="rotZ0" type="range" min="-180" max="180" step="1" value="0">
        </div>


      <div class="row">
        <label>Offset X <small id="vxv">0 px</small></label>
        <input id="offsetX" type="range" min="-300" max="300" step="1" value="0">
      </div>
      <div class="row">
        <label>Offset Y <small id="vyv">40 px</small></label>
        <input id="offsetY" type="range" min="-300" max="300" step="1" value="-60">
      </div>
      <div class="row">
        <label>Ancho relativo (× dist. ojos) <small id="wfv">2.40×</small></label>
        <input id="widthFactor" type="range" min="1.2" max="3.5" step="0.05" value="2.4">
      </div>
      <div class="row">
        <label>Escala extra <small id="esv">1.00×</small></label>
        <input id="extraScale" type="range" min="0.6" max="1.8" step="0.01" value="1.00">
      </div>
      <div class="row">
        <label>Rotación extra (roll) <small id="rov">0°</small></label>
        <input id="rotDeg" type="range" min="-180" max="180" step="1" value="0">
      </div>
      <div class="muted">Base ancho modelo: <b id="baseW">—</b> px</div>

      <div id="buttons">
        <button id="reset" class="secondary">Reset</button>
        <button id="save">Guardar ajustes</button>
      </div>
    </div>
  </div>

    <!-- MediaPipe FaceMesh -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>

    <!-- App -->
    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

      // === CONFIG desde DB (si se abrió con ?model_id=) ===
      const CONFIG_FROM_DB = {% if ar_model and ar_model.config_for_display %}
                              {{ ar_model.config_for_display | tojson }}
                            {% else %}
                              {}
                            {% endif %};

      // === URL para guardado en servidor / ID del modelo (si aplica) ===
      const SAVE_URL = "{{ url_for('main.glb_a_cara', model_id=ar_model.model_id) }}";
      const MODEL_ID = {% if ar_model %} {{ ar_model.model_id }} {% else %} null {% endif %};

      // === HELPERS ===
      function hardenMaterials(root) {
        root.traverse(o => {
          if (!o.isMesh) return;
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          mats.forEach(m => {
            if (!m) return;
            m.depthTest = true;
            m.depthWrite = true;
            m.side = THREE.DoubleSide;
            m.polygonOffset = true;
            m.polygonOffsetFactor = 1;
            m.polygonOffsetUnits = 1;
          });
        });
      }

      // ==== UI & estado ====
      const ui = {
        offsetX:  document.getElementById('offsetX'),
        offsetY:  document.getElementById('offsetY'),
        widthFactor: document.getElementById('widthFactor'),
        extraScale:  document.getElementById('extraScale'),
        rotDeg:   document.getElementById('rotDeg'),
        vxv:      document.getElementById('vxv'),
        vyv:      document.getElementById('vyv'),
        wfv:      document.getElementById('wfv'),
        esv:      document.getElementById('esv'),
        rov:      document.getElementById('rov'),
        reset:    document.getElementById('reset'),
        save:     document.getElementById('save'),
        baseW:    document.getElementById('baseW'),
        trackFace:document.getElementById('trackFace'),
        use3D:    document.getElementById('use3D'),
        rotX0:    document.getElementById('rotX0'),
        rotY0:    document.getElementById('rotY0'),
        rotZ0:    document.getElementById('rotZ0'),
        rx0v:     document.getElementById('rx0v'),
        ry0v:     document.getElementById('ry0v'),
        rz0v:     document.getElementById('rz0v'),
        glbFile:  document.getElementById('glbFile'), // sólo existe si no hay GLB
        glbSrc:   document.getElementById('glbSrc')   // hidden con URL si ya hay GLB
      };

      const STATE_KEY = 'glb_params_v1';
      const defaults = {
        offsetX: 0,
        offsetY: 40,
        widthFactor: 2.4,
        extraScale: 1.0,
        rotDeg: 0,
        trackFace: false, // por defecto NO sigue la cara
        use3D: false,     // yaw/pitch desactivado (solo roll)
        rotX0: 0, rotY0: 0, rotZ0: 0
      };

      // Mezcla: defaults -> LocalStorage -> DB
      const FROM_LS = JSON.parse(localStorage.getItem(STATE_KEY) || '{}');
      const params = { ...defaults, ...FROM_LS, ...CONFIG_FROM_DB };

      function syncUI() {
        ui.offsetX.value = params.offsetX;
        ui.offsetY.value = params.offsetY;
        ui.widthFactor.value = params.widthFactor;
        ui.extraScale.value = params.extraScale;
        ui.rotDeg.value = params.rotDeg;

        ui.vxv.textContent = `${params.offsetX} px`;
        ui.vyv.textContent = `${params.offsetY} px`;
        ui.wfv.textContent = `${params.widthFactor.toFixed(2)}×`;
        ui.esv.textContent = `${params.extraScale.toFixed(2)}×`;
        ui.rov.textContent = `${params.rotDeg}°`;

        ui.trackFace.checked = params.trackFace;
        ui.use3D.checked     = params.use3D;

        ui.rotX0.value = params.rotX0; ui.rx0v.textContent = `${params.rotX0}°`;
        ui.rotY0.value = params.rotY0; ui.ry0v.textContent = `${params.rotY0}°`;
        ui.rotZ0.value = params.rotZ0; ui.rz0v.textContent = `${params.rotZ0}°`;
      }
      syncUI();

      function saveParamsLocal(){ try{ localStorage.setItem(STATE_KEY, JSON.stringify(params)); }catch(_){} }

      async function saveParamsToServer({ redirectOnSuccess = false } = {}) {
        if (!MODEL_ID) return false; 
        try {
          const res = await fetch(SAVE_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(params)
          });
          const json = await res.json().catch(() => null);

          console.log(json)

          const ok = !!(res.ok && json && json.ok === true);
          console.log(ok)

          if (ok && redirectOnSuccess && json.redirect) {
            window.location.assign(json.redirect);
            return true; 
          }

          return ok;
        } catch (e) {
          console.error('No se pudo guardar config_for_display en servidor:', e);
          return false;
        }
      }

      // Handlers UI
      ui.offsetX.oninput = ()=>{ params.offsetX = +ui.offsetX.value; ui.vxv.textContent = `${params.offsetX} px`; };
      ui.offsetY.oninput = ()=>{ params.offsetY = +ui.offsetY.value; ui.vyv.textContent = `${params.offsetY} px`; };
      ui.widthFactor.oninput = ()=>{ params.widthFactor = +ui.widthFactor.value; ui.wfv.textContent = `${params.widthFactor.toFixed(2)}×`; };
      ui.extraScale.oninput = ()=>{ params.extraScale = +ui.extraScale.value; ui.esv.textContent = `${params.extraScale.toFixed(2)}×`; };
      ui.rotDeg.oninput = ()=>{ params.rotDeg = +ui.rotDeg.value; ui.rov.textContent = `${params.rotDeg}°`; };
      ui.reset.onclick = ()=>{ Object.assign(params, defaults); syncUI(); saveParamsLocal(); };
      ui.trackFace.oninput = ()=>{ params.trackFace = ui.trackFace.checked; saveParamsLocal(); };
      ui.use3D.oninput     = ()=>{ params.use3D     = ui.use3D.checked;     saveParamsLocal(); };
      ui.rotX0.oninput = ()=>{ params.rotX0 = +ui.rotX0.value; ui.rx0v.textContent = `${params.rotX0}°`; computeBaseQ(); };
      ui.rotY0.oninput = ()=>{ params.rotY0 = +ui.rotY0.value; ui.ry0v.textContent = `${params.rotY0}°`; computeBaseQ(); };
      ui.rotZ0.oninput = ()=>{ params.rotZ0 = +ui.rotZ0.value; ui.rz0v.textContent = `${params.rotZ0}°`; computeBaseQ(); };

      ui.save.onclick = async () => {
        ui.save.disabled = true;
        try {
          saveParamsLocal();
          const ok = await saveParamsToServer({ redirectOnSuccess: true });
          if (!ok) {
            alert('No se pudo guardar los ajustes. Revisá la consola para más detalles.');
          }
        } finally {
          ui.save.disabled = false;
        }
      };

      // ==== Webcam ====
      const video = document.getElementById('video');
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio:false });
      video.srcObject = stream; await video.play();

      // ==== Three.js ====
      const canvas = document.getElementById('three');
      const renderer = new THREE.WebGLRenderer({ canvas, alpha:true, antialias:true });

      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1;

      // escena y cámara
      const scene = new THREE.Scene();

      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 2000);
      camera.position.z = 10;

      // Luces
      scene.add(new THREE.AmbientLight(0xffffff, 0.85));
      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(0.5, 1, 1);
      scene.add(dir);

      function resize(){
        const W = window.innerWidth, H = window.innerHeight;
        renderer.setSize(W,H,false);
        camera.left = -W/2; camera.right = W/2; camera.top = H/2; camera.bottom = -H/2;
        camera.updateProjectionMatrix();
      }
      addEventListener('resize', resize);
      video.addEventListener('loadedmetadata', resize);
      resize();

      // ==== GLB ====
      const model = new THREE.Group(); scene.add(model);
      let baseWidthPx = 300; // se actualiza al cargar
      ui.baseW.textContent = '—';

      const baseQ = new THREE.Quaternion();
      function computeBaseQ(){
        baseQ.setFromEuler(new THREE.Euler(
          THREE.MathUtils.degToRad(params.rotX0),
          THREE.MathUtils.degToRad(params.rotY0),
          THREE.MathUtils.degToRad(params.rotZ0),
          'XYZ'
        ));
      }
      computeBaseQ();

      function centerAndMeasure(node){
        const box = new THREE.Box3().setFromObject(node);
        const c = box.getCenter(new THREE.Vector3());
        const s = box.getSize(new THREE.Vector3());
        node.position.sub(c);
        return { width: s.x, height: s.y, depth: s.z };
      }

      const loader = new GLTFLoader();

      async function attachModelFromGltf(gltf){
        while(model.children.length) model.remove(model.children[0]);
        const sceneNode = gltf.scene || gltf.scenes?.[0];
        model.add(sceneNode);
        hardenMaterials(sceneNode);
        const dims = centerAndMeasure(sceneNode);
        baseWidthPx = Math.max(1, dims.width);
        ui.baseW.textContent = `${baseWidthPx.toFixed(0)}`;
      }

      async function loadGLBFromFile(file){
        const name = (file.name || '').toLowerCase();
        const isGLB = name.endsWith('.glb') || (file.type || '').includes('model/gltf-binary');
        if (isGLB) {
          const arrayBuffer = await file.arrayBuffer();
          return new Promise((resolve, reject)=>{
            loader.parse(arrayBuffer, /*path*/'', gltf=>resolve(gltf), reject);
          });
        } else {
          const text = await file.text(); // .gltf inline
          return new Promise((resolve, reject)=>{
            loader.parse(text, /*path*/'', gltf=>resolve(gltf), reject);
          });
        }
      }

      async function loadGLB(url){
        return new Promise((resolve, reject)=>{
          loader.load(url,
            async (gltf)=>{ await attachModelFromGltf(gltf); resolve(); },
            undefined,
            (err)=>reject(err)
          );
        });
      }

      // Cargar automáticamente el GLB si ya existe (hidden #glbSrc)
      const initialGlb = ui.glbSrc?.value || "";
      if (initialGlb) {
        try { await loadGLB(initialGlb); } catch(e){ console.error('Error cargando GLB inicial', e); }
      }

      // Input de archivo si no hay GLB subido
      if (ui.glbFile) {
        ui.glbFile.addEventListener('change', async (e)=>{
          const f = e.target.files?.[0]; if(!f) return;
          try {
            const gltf = await loadGLBFromFile(f);
            await attachModelFromGltf(gltf);
          } catch(err){ alert('Error cargando GLB: ' + err); }
        });
      }

      // ==== FaceMesh ====
      const faceMesh = new window.FaceMesh({
        locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`
      });
      faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.6, minTrackingConfidence:0.6 });

      function toScreen(pt){
        const rect = video.getBoundingClientRect();
        const W = renderer.domElement.width, H = renderer.domElement.height;
        const x = (1-pt.x)*rect.width;  // espejo horizontal (video está espejado)
        const y = pt.y*rect.height;
        const sx = x - rect.width/2, sy = rect.height/2 - y;
        const scaleX = W/rect.width, scaleY = H/rect.height;
        return new THREE.Vector3(sx*scaleX, sy*scaleY, 0);
      }

      // Suavizado
      const smooth = { pos: new THREE.Vector3(), rot: new THREE.Euler(), scale: 1, alphaPos: 0.25, alphaRot: 0.25, alphaScl: 0.25 };
      function lerpAngle(a, b, t){
        let d = (b - a + Math.PI) % (2*Math.PI) - Math.PI;
        return a + d * t;
      }

      function onResults(res){
        if (model.children.length === 0) return;

        // ===== MODO ESTÁTICO (Seguir cara OFF) =====
        if (!params.trackFace) {
          model.position.set(params.offsetX, params.offsetY, 0);

          const W = renderer.domElement.width;
          const defaultWidth = 0.40 * W;
          const s = (defaultWidth / Math.max(1, baseWidthPx)) * params.extraScale;
          model.scale.setScalar(s);

          const rollExtra = THREE.MathUtils.degToRad(params.rotDeg);
          const qRoll = new THREE.Quaternion().setFromEuler(new THREE.Euler(0,0,rollExtra,'YXZ'));
          model.quaternion.copy(baseQ).multiply(qRoll);
          return;
        }

        // ===== MODO SEGUIR CARA =====
        const lm = res.multiFaceLandmarks?.[0];
        if (!lm) return;

        const L=33, R=263, NOSE=1;

        // ---- Centros y escala en pantalla (espejados) ----
        const pL = toScreen(lm[L]);
        const pR = toScreen(lm[R]);
        const center = pL.clone().add(pR).multiplyScalar(0.5);
        const dxS = pR.x - pL.x, dyS = pR.y - pL.y;
        const dist = Math.hypot(dxS, dyS);

        // ---- Orientación en coords no espejadas ----
        const dx0 = lm[R].x - lm[L].x;
        const dy0 = lm[R].y - lm[L].y;

        // roll (Z)
        let roll = Math.atan2(dy0, dx0);

        // yaw (Y) y pitch (X)
        const denomYaw   = Math.max(1e-3, Math.abs(dx0));
        const denomPitch = Math.max(1e-3, Math.abs(lm[NOSE].y - (lm[L].y + lm[R].y)/2));
        let yaw   = Math.atan((lm[R].z - lm[L].z) / denomYaw);
        let pitch = Math.atan((lm[NOSE].z - (lm[L].z + lm[R].z)/2) / denomPitch);

        // Si use3D está OFF, ignorar yaw/pitch
        if (!params.use3D) { yaw = 0; pitch = 0; }

        yaw   = THREE.MathUtils.clamp(yaw,   -0.8, 0.8);
        pitch = THREE.MathUtils.clamp(pitch, -0.6, 0.6);

        const targetPos = new THREE.Vector3(center.x + params.offsetX, center.y + params.offsetY, 0);
        const desiredWidth = dist * params.widthFactor;
        const targetScale  = (desiredWidth / Math.max(1, baseWidthPx)) * params.extraScale;

        const rotExtra = params.rotDeg * Math.PI / 180;
        const targetRot = new THREE.Euler(pitch, yaw, roll + rotExtra, 'YXZ');

        // Suavizado
        smooth.pos.lerp(targetPos, smooth.alphaPos);
        smooth.scale = THREE.MathUtils.lerp(smooth.scale, targetScale, smooth.alphaScl);
        smooth.rot.x = lerpAngle(smooth.rot.x, targetRot.x, smooth.alphaRot);
        smooth.rot.y = lerpAngle(smooth.rot.y, targetRot.y, smooth.alphaRot);
        smooth.rot.z = lerpAngle(smooth.rot.z, targetRot.z, smooth.alphaRot);

        model.position.copy(smooth.pos);
        model.scale.setScalar(smooth.scale);

        const followQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(smooth.rot.x, smooth.rot.y, smooth.rot.z, 'YXZ'));
        model.quaternion.copy(baseQ);
        model.quaternion.premultiply(followQ);
      }

      faceMesh.onResults(onResults);

      const cam = new window.Camera(video, {
        onFrame: async()=>{ await faceMesh.send({ image: video }); },
        width: 1280, height: 720
      });
      cam.start();

      // ==== render loop ====
      (function loop(){ renderer.render(scene,camera); requestAnimationFrame(loop); })();
    </script>

</body>
</html>
