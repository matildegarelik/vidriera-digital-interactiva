<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>GLB sobre la cara (FaceMesh + Three.js)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#000; font-family: system-ui, Arial, sans-serif; }
    #wrap { position:relative; width:100vw; height:100vh; overflow:hidden; }
    #video { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform:scaleX(-1); }
    #three { position:absolute; inset:0; pointer-events:none; }
    #ui {
      position:absolute; top:10px; left:10px; z-index:10;
      background: rgba(0,0,0,.55); backdrop-filter: blur(6px);
      padding:12px 14px; border-radius:12px; color:#fff; width:min(360px, 92vw);
      box-shadow: 0 8px 24px rgba(0,0,0,.35);
    }
    #ui h3 { margin:0 0 8px; font-size:16px; font-weight:600; }
    .row { display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; margin:8px 0; }
    .row input[type="range"] { width:100%; }
    .row small { opacity:.85; }
    .muted { opacity:.8; font-size:12px; }
    #glbInput { width:100%; margin-top:6px; }
    #buttons { display:flex; gap:8px; margin-top:8px; }
    button { background:#1f6feb; color:#fff; border:none; padding:8px 10px; border-radius:8px; cursor:pointer; }
    button.secondary { background:#444; }
  </style>

  <!-- Import Map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="wrap">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="three"></canvas>

    <div id="ui">
      <h3>GLB sobre la cara</h3>
      <input id="glbInput" type="file" accept=".glb,.gltf,model/gltf-binary,model/gltf+json" />
      <div class="muted">Cargá tu <b>marco_completo.glb</b>.</div>

      <div class="row">
        <label><input id="trackFace" type="checkbox"> Seguir cara</label><span></span>
      </div>
      <div class="row">
        <label><input id="use3D" type="checkbox"> Yaw/Pitch (3D)</label><span></span>
      </div>

      <h4 style="margin:6px 0 0; font-size:13px;">Rotación inicial del GLB</h4>
      <div class="row">
            <label>Rot X <small id="rx0v">0°</small></label>
            <input id="rotX0" type="range" min="-180" max="180" step="1" value="-180">
        </div>
        <div class="row">
            <label>Rot Y <small id="ry0v">0°</small></label>
            <input id="rotY0" type="range" min="-180" max="180" step="1" value="0">
            </div>
            <div class="row">
            <label>Rot Z <small id="rz0v">0°</small></label>
            <input id="rotZ0" type="range" min="-180" max="180" step="1" value="0">
        </div>


      <div class="row">
        <label>Offset X <small id="vxv">0 px</small></label>
        <input id="offsetX" type="range" min="-300" max="300" step="1" value="0">
      </div>
      <div class="row">
        <label>Offset Y <small id="vyv">40 px</small></label>
        <input id="offsetY" type="range" min="-300" max="300" step="1" value="40">
      </div>
      <div class="row">
        <label>Ancho relativo (× dist. ojos) <small id="wfv">2.40×</small></label>
        <input id="widthFactor" type="range" min="1.2" max="3.5" step="0.05" value="2.4">
      </div>
      <div class="row">
        <label>Escala extra <small id="esv">1.00×</small></label>
        <input id="extraScale" type="range" min="0.6" max="1.8" step="0.01" value="1.00">
      </div>
      <div class="row">
        <label>Rotación extra (roll) <small id="rov">0°</small></label>
        <input id="rotDeg" type="range" min="-180" max="180" step="1" value="0">
      </div>
      <div class="muted">Base ancho modelo: <b id="baseW">—</b> px</div>

      <div id="buttons">
        <button id="reset" class="secondary">Reset</button>
        <button id="save">Guardar ajustes</button>
      </div>
    </div>
  </div>

  <!-- MediaPipe FaceMesh -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>

  <!-- App -->
  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

    // HELPERS
    function hardenMaterials(root) {
        root.traverse(o => {
            if (!o.isMesh) return;
            const mats = Array.isArray(o.material) ? o.material : [o.material];
            mats.forEach(m => {
            if (!m) return;
            m.transparent = false;          // fuerza opaco
            m.opacity = 1;
            m.depthTest = true;
            m.depthWrite = true;            // escribe al z-buffer
            m.side = THREE.DoubleSide;      // evita desaparecer por normales
            // Mitiga z-fighting si hay planos coplanares:
            m.polygonOffset = true;
            m.polygonOffsetFactor = 1;
            m.polygonOffsetUnits = 1;
            });
        });
    }

    
    // ==== UI & estado ====
    const ui = {
      offsetX: document.getElementById('offsetX'),
      offsetY: document.getElementById('offsetY'),
      widthFactor: document.getElementById('widthFactor'),
      extraScale: document.getElementById('extraScale'),
      rotDeg: document.getElementById('rotDeg'),
      vxv: document.getElementById('vxv'),
      vyv: document.getElementById('vyv'),
      wfv: document.getElementById('wfv'),
      esv: document.getElementById('esv'),
      rov: document.getElementById('rov'),
      reset: document.getElementById('reset'),
      save: document.getElementById('save'),
      glbInput: document.getElementById('glbInput'),
      baseW: document.getElementById('baseW'),
      trackFace: document.getElementById('trackFace'),
        use3D:     document.getElementById('use3D'),
        rotX0:     document.getElementById('rotX0'),
        rotY0:     document.getElementById('rotY0'),
        rotZ0:     document.getElementById('rotZ0'),
        rx0v:      document.getElementById('rx0v'),
        ry0v:      document.getElementById('ry0v'),
        rz0v:      document.getElementById('rz0v'),

    };

    const STATE_KEY = 'glb_params_v1';
    const defaults = {
      offsetX: 0,
      offsetY: 40,
      widthFactor: 2.4,
      extraScale: 1.0,
      rotDeg: 0,
      trackFace: false,   // ← por defecto NO sigue la cara
      use3D: false,       // yaw/pitch desactivado (solo roll)
      rotX0: 0, rotY0: 0, rotZ0: 0

    };
    const params = { ...defaults, ...(JSON.parse(localStorage.getItem(STATE_KEY) || '{}')) };

    function syncUI() {
      ui.offsetX.value = params.offsetX;
      ui.offsetY.value = params.offsetY;
      ui.widthFactor.value = params.widthFactor;
      ui.extraScale.value = params.extraScale;
      ui.rotDeg.value = params.rotDeg;
      ui.vxv.textContent = `${params.offsetX} px`;
      ui.vyv.textContent = `${params.offsetY} px`;
      ui.wfv.textContent = `${params.widthFactor.toFixed(2)}×`;
      ui.esv.textContent = `${params.extraScale.toFixed(2)}×`;
      ui.rov.textContent = `${params.rotDeg}°`;
      ui.trackFace.checked = params.trackFace;
      ui.use3D.checked     = params.use3D;
      ui.rotX0.value = params.rotX0; ui.rx0v.textContent = `${params.rotX0}°`;
      ui.rotY0.value = params.rotY0; ui.ry0v.textContent = `${params.rotY0}°`;
      ui.rotZ0.value = params.rotZ0; ui.rz0v.textContent = `${params.rotZ0}°`;

    }
    syncUI();

    function saveParams(){ localStorage.setItem(STATE_KEY, JSON.stringify(params)); }
    ui.offsetX.oninput = ()=>{ params.offsetX = +ui.offsetX.value; ui.vxv.textContent = `${params.offsetX} px`; };
    ui.offsetY.oninput = ()=>{ params.offsetY = +ui.offsetY.value; ui.vyv.textContent = `${params.offsetY} px`; };
    ui.widthFactor.oninput = ()=>{ params.widthFactor = +ui.widthFactor.value; ui.wfv.textContent = `${params.widthFactor.toFixed(2)}×`; };
    ui.extraScale.oninput = ()=>{ params.extraScale = +ui.extraScale.value; ui.esv.textContent = `${params.extraScale.toFixed(2)}×`; };
    ui.rotDeg.oninput = ()=>{ params.rotDeg = +ui.rotDeg.value; ui.rov.textContent = `${params.rotDeg}°`; };
    ui.reset.onclick = ()=>{ Object.assign(params, defaults); syncUI(); saveParams(); };
    ui.save.onclick = ()=> saveParams();
    ui.trackFace.oninput = ()=>{ params.trackFace = ui.trackFace.checked; saveParams(); };
    ui.use3D.oninput     = ()=>{ params.use3D     = ui.use3D.checked; saveParams(); };
    ui.rotX0.oninput = ()=>{ params.rotX0 = +ui.rotX0.value; ui.rx0v.textContent = `${params.rotX0}°`; computeBaseQ(); };
    ui.rotY0.oninput = ()=>{ params.rotY0 = +ui.rotY0.value; ui.ry0v.textContent = `${params.rotY0}°`; computeBaseQ(); };
    ui.rotZ0.oninput = ()=>{ params.rotZ0 = +ui.rotZ0.value; ui.rz0v.textContent = `${params.rotZ0}°`; computeBaseQ(); };


    // ==== Webcam ====
    const video = document.getElementById('video');
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio:false });
    video.srcObject = stream; await video.play();

    // ==== Three.js ====
    const canvas = document.getElementById('three');
    const renderer = new THREE.WebGLRenderer({ canvas, alpha:true, antialias:true });

    // nitidez y color
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1;

// escena y cámara
const scene = new THREE.Scene();

// near > 0 sí o sí, y far bien grande para precisión
const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 2000);
camera.position.z = 10; // un poco más lejos mejora precision

    // Luces para que el GLB se vea
    scene.add(new THREE.AmbientLight(0xffffff, 0.85));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(0.5, 1, 1);
    scene.add(dir);

    function resize(){
      const W = window.innerWidth, H = window.innerHeight;
      renderer.setSize(W,H,false);
      camera.left = -W/2; camera.right = W/2; camera.top = H/2; camera.bottom = -H/2;
      camera.updateProjectionMatrix();
    }
    addEventListener('resize', resize);
    video.addEventListener('loadedmetadata', resize);
    resize();

    // ==== GLB ====
    // Grupo contenedor (lo muevo/escalo/roto entero)
    const model = new THREE.Group(); scene.add(model);
    // Dentro del grupo meto el gltf.scene centrado y con su baseWidth calculado
    let baseWidthPx = 300; // se reemplaza al cargar
    ui.baseW.textContent = '—';

    const baseQ = new THREE.Quaternion();
    function computeBaseQ(){
    baseQ.setFromEuler(new THREE.Euler(
        THREE.MathUtils.degToRad(params.rotX0),
        THREE.MathUtils.degToRad(params.rotY0),
        THREE.MathUtils.degToRad(params.rotZ0),
        'XYZ'
    ));
    }
    computeBaseQ();


    function centerAndMeasure(node){
        const box = new THREE.Box3().setFromObject(node);
        const c = box.getCenter(new THREE.Vector3());
        const s = box.getSize(new THREE.Vector3());
        node.position.sub(c); // centra el propio nodo
        return { width: s.x, height: s.y, depth: s.z };
    }


    async function loadGLBFromFile(file){
        const loader = new GLTFLoader();

        // Si es GLB => ArrayBuffer; si es GLTF => texto (por si acaso)
        const name = (file.name || '').toLowerCase();
        const isGLB = name.endsWith('.glb') || (file.type || '').includes('model/gltf-binary');

        if (isGLB) {
            const arrayBuffer = await file.arrayBuffer();
            return new Promise((resolve, reject)=>{
            loader.parse(arrayBuffer, /*path*/'', gltf=>resolve(gltf), reject);
            });
        } else {
            const text = await file.text(); // .gltf (sin recursos externos)
            return new Promise((resolve, reject)=>{
            loader.parse(text, /*path*/'', gltf=>resolve(gltf), reject);
            });
        }
    }


    ui.glbInput.addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if(!f) return;
      try{
        const gltf = await loadGLBFromFile(f);
        /// limpiar modelo anterior
        while(model.children.length) model.remove(model.children[0]);
        const sceneNode = gltf.scene || gltf.scenes?.[0];
        model.add(sceneNode);
        hardenMaterials(sceneNode);

        // Centrar y medir el NODO
        const dims = centerAndMeasure(sceneNode);
        baseWidthPx = Math.max(1, dims.width);
        ui.baseW.textContent = `${baseWidthPx.toFixed(0)}`;

        // Si aparece acostado, probá esto:
        // params.rotX0 = -90; computeBaseQ(); syncUI();


      } catch(err){
        alert('Error cargando GLB: ' + err);
      }
    });

    // ==== FaceMesh ====
    const faceMesh = new window.FaceMesh({
      locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`
    });
    faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.6, minTrackingConfidence:0.6 });

    function toScreen(pt){
      const rect = video.getBoundingClientRect();
      const W = renderer.domElement.width, H = renderer.domElement.height;
      const x = (1-pt.x)*rect.width;  // espejo horizontal (video está espejado)
      const y = pt.y*rect.height;
      const sx = x - rect.width/2, sy = rect.height/2 - y;
      const scaleX = W/rect.width, scaleY = H/rect.height;
      return new THREE.Vector3(sx*scaleX, sy*scaleY, 0);
    }

    // Suavizado para evitar jitter
    const smooth = {
      pos: new THREE.Vector3(), rot: new THREE.Euler(), scale: 1,
      alphaPos: 0.25, alphaRot: 0.25, alphaScl: 0.25
    };
    function lerpAngle(a, b, t){
      let d = (b - a + Math.PI) % (2*Math.PI) - Math.PI;
      return a + d * t;
    }

    function onResults(res){
  if (model.children.length === 0) return;

  // ===== MODO ESTÁTICO (Seguir cara OFF) =====
  if (!params.trackFace) {
    model.position.set(params.offsetX, params.offsetY, 0);

    const W = renderer.domElement.width;
    const defaultWidth = 0.40 * W;
    const s = (defaultWidth / Math.max(1, baseWidthPx)) * params.extraScale;
    model.scale.setScalar(s);

    const rollExtra = THREE.MathUtils.degToRad(params.rotDeg);
    const qRoll = new THREE.Quaternion().setFromEuler(new THREE.Euler(0,0,rollExtra,'YXZ'));
    model.quaternion.copy(baseQ).multiply(qRoll);
    return;
  }

  // ===== MODO SEGUIR CARA =====
  const lm = res.multiFaceLandmarks?.[0];
  if (!lm) return;

  const L=33, R=263, NOSE=1;

  // ---- Centros y escala: usar puntos en PANTALLA (espejados) ----
    const pL = toScreen(lm[L]);
    const pR = toScreen(lm[R]);
    const center = pL.clone().add(pR).multiplyScalar(0.5);
    const dxS = pR.x - pL.x, dyS = pR.y - pL.y;
    const dist = Math.hypot(dxS, dyS);   // escala con distancia en pantalla

    // ---- Orientación: usar coords ORIGINALES (NO espejadas) ----
    const dx0 = lm[R].x - lm[L].x;
    const dy0 = lm[R].y - lm[L].y;

    // roll (Z): del par de ojos en coords sin espejo, luego INVERTIR por el espejo
    let roll = Math.atan2(dy0, dx0);   // ← el "-" corrige el espejo horizontal

    // yaw (Y) y pitch (X) desde z normalizado
    const denomYaw   = Math.max(1e-3, Math.abs(dx0));
    const denomPitch = Math.max(1e-3, Math.abs(lm[NOSE].y - (lm[L].y + lm[R].y)/2));
    let yaw   = Math.atan((lm[R].z - lm[L].z) / denomYaw);
    let pitch = Math.atan((lm[NOSE].z - (lm[L].z + lm[R].z)/2) / denomPitch);

    // espejo: yaw va invertido, pitch igual
    yaw   = THREE.MathUtils.clamp(yaw, -0.8, 0.8);
    pitch = THREE.MathUtils.clamp(pitch, -0.6, 0.6);


  const targetPos = new THREE.Vector3(center.x + params.offsetX, center.y + params.offsetY, 0);
  const desiredWidth = dist * params.widthFactor;
  const targetScale  = (desiredWidth / Math.max(1, baseWidthPx)) * params.extraScale;

  const rotExtra = params.rotDeg * Math.PI / 180;
  const targetRot = new THREE.Euler(pitch, yaw, roll + rotExtra, 'YXZ');

  // Suavizado
  smooth.pos.lerp(targetPos, smooth.alphaPos);
  smooth.scale = THREE.MathUtils.lerp(smooth.scale, targetScale, smooth.alphaScl);
  smooth.rot.x = lerpAngle(smooth.rot.x, targetRot.x, smooth.alphaRot);
  smooth.rot.y = lerpAngle(smooth.rot.y, targetRot.y, smooth.alphaRot);
  smooth.rot.z = lerpAngle(smooth.rot.z, targetRot.z, smooth.alphaRot);

  model.position.copy(smooth.pos);
  model.scale.setScalar(smooth.scale);

  const followQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(smooth.rot.x, smooth.rot.y, smooth.rot.z, 'YXZ'));
  model.quaternion.copy(baseQ);            // tu orientación base (sliders)
  model.quaternion.premultiply(followQ);   // aplicar yaw/pitch/roll en ejes de pantalla
}

    faceMesh.onResults(onResults);


    const cam = new window.Camera(video, {
    onFrame: async()=>{ await faceMesh.send({ image: video }); },
        width: 1280, height: 720
    });
    cam.start();

    // ==== render loop ====
    (function loop(){ renderer.render(scene,camera); requestAnimationFrame(loop); })();


    

  </script>
</body>
</html>
